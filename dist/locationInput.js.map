{"version":3,"file":"locationInput.js","sources":["../src/mapml/elementSupport/inputs/locationInput.js"],"sourcesContent":["export class LocationInput {\n  constructor(name, position, axis, units, min, max, rel, layer) {\n    this.name = name;\n    this.position = position;\n    this.axis = axis;\n    // if unit/cs not present, find it\n    if (!units && axis && !['i', 'j'].includes(axis)) {\n      this.units = M.axisToCS(axis).toLowerCase();\n    } else {\n      this.units = units; // cs\n    }\n    this.min = min;\n    this.max = max;\n    this.rel = rel;\n    this.layer = layer;\n  }\n\n  validateInput() {\n    // name is required\n    // axis is required\n    if (!this.name || !this.axis) {\n      return false;\n    }\n    // cs/units is only required when the axis is i/j. To differentiate between the units/cs\n    if (\n      (this.axis === 'i' || this.axis === 'j') &&\n      !['map', 'tile'].includes(this.units)\n    ) {\n      return false;\n    }\n    // check if axis match the units/cs\n    if (this.units) {\n      let axisCS = M.axisToCS(this.axis);\n      if (\n        typeof axisCS === 'string' &&\n        axisCS.toUpperCase() !== this.units.toUpperCase()\n      ) {\n        return false;\n      }\n    }\n    // position is not required, will default to top-left\n    // min max fallbacks, map-meta -> projection\n    // rel not required, default is image/extent\n    return true;\n  }\n\n  _TCRSToPCRS(coords, zoom) {\n    // TCRS pixel point to Projected CRS point (in meters, presumably)\n    var map = this.layer._map,\n      crs = map.options.crs,\n      loc = crs.transformation.untransform(coords, crs.scale(zoom));\n    return loc;\n  }\n\n  getValue(zoom = undefined, bounds = undefined) {\n    // units = cs\n    //<input name=\"...\" units=\"pcrs\" type=\"location\" position=\"top|bottom-left|right\" axis=\"northing|easting|latitude|longitude\">\n    if (zoom === undefined) zoom = this.layer._map.getZoom();\n    if (bounds === undefined) bounds = this.layer._map.getPixelBounds();\n\n    if (this.units === 'pcrs' || this.units === 'gcrs') {\n      switch (this.axis) {\n        case 'longitude':\n        case 'easting':\n          if (this.position) {\n            if (this.position.match(/.*?-left/i)) {\n              return this._TCRSToPCRS(bounds.min, zoom).x;\n            } else if (this.position.match(/.*?-right/i)) {\n              return this._TCRSToPCRS(bounds.max, zoom).x;\n            }\n          } else {\n            // position is not required, will default to top-left\n            return this._TCRSToPCRS(bounds.min, zoom).x;\n          }\n          break;\n        case 'latitude':\n        case 'northing':\n          if (this.position) {\n            if (this.position.match(/top-.*?/i)) {\n              return this._TCRSToPCRS(bounds.min, zoom).y;\n            } else if (this.position.match(/bottom-.*?/i)) {\n              return this._TCRSToPCRS(bounds.max, zoom).y;\n            }\n          } else {\n            // position is not required, will default to top-left\n            return this._TCRSToPCRS(bounds.min, zoom).y;\n          }\n          break;\n      }\n    } else if (this.units === 'tilematrix') {\n      // Value is retrieved from the createTile method of TemplatedTileLayer, on move end.\n      // Different values for each tile when filling in the map tiles on the map.\n      // Currently storing all x,y,z within one object,\n      // TODO: change return value as needed based on usage by map-input\n      // https://github.com/Leaflet/Leaflet/blob/6994baf25f267db1c8b720c28a61e0700d0aa0e8/src/layer/tile/GridLayer.js#L652\n      const center = this.layer._map.getCenter();\n      const templatedTileLayer = this.layer._templatedLayer._templates[0].layer;\n      const pixelBounds = templatedTileLayer._getTiledPixelBounds(center);\n      const tileRange = templatedTileLayer._pxBoundsToTileRange(pixelBounds);\n      let obj = [];\n      for (let j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (let i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          const coords = new L.Point(i, j);\n          coords.z = templatedTileLayer._tileZoom;\n          obj.push(coords);\n        }\n      }\n      return obj;\n    } else if (this.units === 'tile' || this.units === 'map') {\n      // used for query handler on map enter or click.\n      // mapi, tilei, mapj, tilej used for query handling, value is derived from the mouse click event\n      // or center of the map when used with keyboard.\n      if (this['click' + this.axis]) {\n        return this['click' + this.axis];\n      }\n    }\n    return;\n  }\n}\n"],"names":["LocationInput","constructor","name","position","axis","units","min","max","rel","layer","this","includes","M","axisToCS","toLowerCase","validateInput","let","axisCS","toUpperCase","_TCRSToPCRS","coords","zoom","crs","_map","options","transformation","untransform","scale","getValue","undefined","bounds","getZoom","getPixelBounds","x","match","y","center","getCenter","templatedTileLayer","_templatedLayer","_templates","pixelBounds","_getTiledPixelBounds","tileRange","_pxBoundsToTileRange","obj","j","i","L","Point","z","_tileZoom","push"],"mappings":";;MAAaA,cACXC,YAAYC,EAAMC,EAAUC,EAAMC,EAAOC,EAAKC,EAAKC,EAAKC,GACtDC,KAAKR,KAAOA,EACZQ,KAAKP,SAAWA,EAChBO,KAAKN,KAAOA,EAEPC,IAASD,GAAS,CAAC,IAAK,KAAKO,SAASP,GAGzCM,KAAKL,MAAQA,EAFbK,KAAKL,MAAQO,EAAEC,SAAST,GAAMU,cAIhCJ,KAAKJ,IAAMA,EACXI,KAAKH,IAAMA,EACXG,KAAKF,IAAMA,EACXE,KAAKD,MAAQA,EAGfM,gBAGE,IAAKL,KAAKR,OAASQ,KAAKN,KACtB,OAAO,EAGT,IACiB,MAAdM,KAAKN,MAA8B,MAAdM,KAAKN,QAC1B,CAAC,MAAO,QAAQO,SAASD,KAAKL,OAE/B,OAAO,EAGT,GAAIK,KAAKL,MAAO,CACdW,IAAIC,EAASL,EAAEC,SAASH,KAAKN,MAC7B,GACoB,iBAAXa,GACPA,EAAOC,gBAAkBR,KAAKL,MAAMa,cAEpC,OAAO,EAMX,OAAO,EAGTC,YAAYC,EAAQC,GAElB,IACEC,EADQZ,KAAKD,MAAMc,KACTC,QAAQF,IAEpB,OADQA,EAAIG,eAAeC,YAAYN,EAAQE,EAAIK,MAAMN,IAI3DO,SAASP,OAAOQ,EAAWC,OAASD,GAMlC,QAHaA,IAATR,IAAoBA,EAAOX,KAAKD,MAAMc,KAAKQ,gBAChCF,IAAXC,IAAsBA,EAASpB,KAAKD,MAAMc,KAAKS,kBAEhC,SAAftB,KAAKL,OAAmC,SAAfK,KAAKL,MAChC,OAAQK,KAAKN,MACX,IAAK,YACL,IAAK,UACH,IAAIM,KAAKP,SAQP,OAAOO,KAAKS,YAAYW,EAAOxB,IAAKe,GAAMY,EAP1C,GAAIvB,KAAKP,SAAS+B,MAAM,aACtB,OAAOxB,KAAKS,YAAYW,EAAOxB,IAAKe,GAAMY,EACrC,GAAIvB,KAAKP,SAAS+B,MAAM,cAC7B,OAAOxB,KAAKS,YAAYW,EAAOvB,IAAKc,GAAMY,EAM9C,MACF,IAAK,WACL,IAAK,WACH,IAAIvB,KAAKP,SAQP,OAAOO,KAAKS,YAAYW,EAAOxB,IAAKe,GAAMc,EAP1C,GAAIzB,KAAKP,SAAS+B,MAAM,YACtB,OAAOxB,KAAKS,YAAYW,EAAOxB,IAAKe,GAAMc,EACrC,GAAIzB,KAAKP,SAAS+B,MAAM,eAC7B,OAAOxB,KAAKS,YAAYW,EAAOvB,IAAKc,GAAMc,MAQ7C,CAAA,GAAmB,eAAfzB,KAAKL,MAAwB,CAMtC,IAAM+B,EAAS1B,KAAKD,MAAMc,KAAKc,YAC/B,MAAMC,EAAqB5B,KAAKD,MAAM8B,gBAAgBC,WAAW,GAAG/B,MACpE,IAAMgC,EAAcH,EAAmBI,qBAAqBN,GACtDO,EAAYL,EAAmBM,qBAAqBH,GAC1DzB,IAAI6B,EAAM,GACV,IAAK7B,IAAI8B,EAAIH,EAAUrC,IAAI6B,EAAGW,GAAKH,EAAUpC,IAAI4B,EAAGW,IAClD,IAAK9B,IAAI+B,EAAIJ,EAAUrC,IAAI2B,EAAGc,GAAKJ,EAAUpC,IAAI0B,EAAGc,IAAK,CACvD,MAAM3B,EAAS,IAAI4B,EAAEC,MAAMF,EAAGD,GAC9B1B,EAAO8B,EAAIZ,EAAmBa,UAC9BN,EAAIO,KAAKhC,GAGb,OAAOyB,EACF,IAAmB,SAAfnC,KAAKL,OAAmC,QAAfK,KAAKL,QAInCK,KAAK,QAAUA,KAAKN,MACtB,OAAOM,KAAK,QAAUA,KAAKN,eAjHtBJ"}